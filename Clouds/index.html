<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric Rendering using Path Tracing</title>
    <link rel="stylesheet" href="style.css">
    
    <!-- MathJax for LaTeX support -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <div class="back-button">
        <a href="../index.html">← Back to Main</a>
    </div>
    
    <div class="container">
        <header class="main-header">
            <h1>Volumetric Rendering using Path Tracing</h1>
            <div class="date">Created 07 December 2025</div>
        </header>

        <div class="main-image">
            <img src="Images/Cloud0.png" alt="Volumetric cloud rendering" width="100%">
        </div>

        <div class="content">
            <nav class="table-of-contents">
                <h3>Table of Contents</h3>
                <ul>
                    <li><a href="#brief">Brief</a></li>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#tracking">Tracking In Homogeneous Volumes</a></li>
                    <li><a href="#phase-functions">Phase Functions</a></li>
                    <li><a href="#heterogeneous-volumes">Heterogeneous Volumes</a></li>
                    <li><a href="#performance-and-optimizations">Performance And Optimizations</a></li>
                    <li><a href="#results-and-comparison">Results and Comparison</a></li>
                </ul>
            </nav>

            <section id="brief">
                <h2>Brief</h2>
                <p>
                    This post is a little write up of volumetric rendering in my GPU path tracer. I'll mostly go over the specific algorithms used, problems encountered, and the solutions that I found. But I won't be discussing the full implementation details of the path tracer itself here, like launching a ray, accumulating the radiance, utilizing the GPU, and so on, since it's a huge topic on it's own and I want to keep this as brief as possible. So this assumes you already know the basics of path tracing and will only focus on the volumetric rendering part. I won't be sharing any code here because it's mostly just math formulas which translate to code directly, and the implementation of the delta tracking is very heavily dependent on the workflow of the path tracer itself, so pasting code snippets without context would just be confusing, and pasting the entire code of the path tracer would be too long. If you're interested in the source code of the path tracer, you can find it on <a href="https://github.com/Zydak/Vulkan-Path-Tracer">GitHub</a>, it's fully open source.
                </p>
            </section>

            <section id="introduction">
                <h2>Introduction</h2>
                <p>
                    There are two main ways of rendering participating media. The first method just marches the ray through the volume in small steps (usually called ray marching), evaluating the medium's properties at each step, and accumulating the transmittance and in scattered light along the way. This is what is commonly used in real-time applications like games, since it's fast and easy to implement.

                    <div class="centered-container column">
                        <img src="Images/RayMarching.png" alt="Ray Marching Illustration">
                        <div class="caption">Ray Marching</div>
                    </div>
                </p>
                <p>
                    But that's not how light behaves in the real world, it doesn't just travel in a straight line, so this method has a major issue, it doesn't account for indirect lighting. In reality, light bounces around and interacts with the medium's particles multiple times instead of just traveling in a straight line, that's called <strong>multiple scattering</strong>. And that's exactly what the second method, <strong>tracking</strong>, accounts for. It simulates and <strong>tracks</strong> all interactions of a light ray with medium's particles as it travels through it. These particles are of course way too small to simulate individually, so a statistical approach is used instead, where the decision to scatter/absorb/continue is made at random based on some probability. It's more accurate but also way more computationally expensive. Because it relies on random numbers it's stochastic in nature, which means the results can be noisy and require multiple samples to converge to a smooth result. And because rays can exit at any point in the medium it nicely accounts for indirect lighting, not just direct lighting from light sources.

                    <div class="image-comparison">
                        <div class="centered-container column">
                            <img src="Images/LightInVolume.png" alt="LightInVolume">
                            <div class="caption">Tracking</div>
                        </div>
                    </div>
                </p>

                <p>
                    Getting good quality results with ray marching can be hard since it requires a lot of cheap tricks like fixed ambient lighting to look good. Since the aim is for maximum quality, I went with tracking.
                </p>
            </section>

            <section id="tracking">
                <h2>Tracking In Homogeneous Volumes</h2>
                <p>
                    For now let's assume that the medium is homogeneous (uniform). These volumes are described by two properties: <strong>absorption coefficient</strong> $\sigma_a$ and <strong>scattering coefficient</strong> $\sigma_s$ that are the same across the entire volume. The absorption coefficient defines how much light is absorbed per unit distance traveled in the medium, while the scattering coefficient defines how much light is scattered per unit distance. Together, they define the <strong>extinction coefficient</strong> $\sigma_t$, which is the sum of the two $\sigma_t = \sigma_a + \sigma_s$. The rate at which light gets absorbed or scattered as it travels through the medium is given by Beer's law. It dictates how much light remains untouched after traveling a distance $d$ in the medium, this quantity is called <strong>transmittance</strong> $T(d)$.
                </p>

                <div class="equation">
                    $$
                    T(d) = e^{-\sigma_t d}
                    $$
                </div>

                <p>
                    Transmittance is important when you need to know how much light reaches a certain point in the medium. This is useful for calculating direct lighting from light sources (NEE), which will significantly reduce noise and speed up convergence.
                </p>

                <p>
                    As earlier said, there are too many particles in a medium to simulate them individually, so a probabilistic approach has to be used to determine how light interacts with the volume. The idea is to sample a random distance at which the next interaction (scattering or absorption) occurs based on some probability that's based on the medium's properties. This probability is given by:
                </p>

                <div class="equation">
                    $$
                    p(d) = \sigma_t e^{-\sigma_t d}
                    $$
                </div>

                <p>
                    The distance $d$ which light ray travels through the medium before an interaction (scattering or absorption) occurs is called the <strong>free path length</strong>, and we want it to be sampled based on the probability $p(d)$. To do that inverse transform sampling can be used and $d$ ends up being defined as:
                </p>

                <div class="equation">
                    $$
                    d = -\frac{\ln(\xi)}{\sigma_t}
                    $$
                </div>

                <p>
                    Where $\xi$ is a uniformly distributed random number in the range [0, 1]. Once the free path length is sampled, the ray can be marched through the medium by this distance. At that point, the decision is made whether the interaction is a scattering or absorption event based on the ratio of scattering to absorption coefficients. Probability of absorption is given by $p_{absorb} = \frac{\sigma_a}{\sigma_t}$ and scattering by $p_{scatter} = \frac{\sigma_s}{\sigma_t}$. To decide whether the event is a scattering or absorption, another random number $\xi$ uniformly distributed in [0, 1] can be used. If $\xi < p_{scatter}$, the event is a scattering event, otherwise, it is an absorption event. Also note that if the sampled distance exceeds the distance to the medium boundary, the ray exits the medium without any interaction. This boundary can be defined in any manner, for example a simple axis aligned bounding box (AABB) or a mesh, all you really need is the distance to the boundary to check if the sampled distance is valid.
                </p>

                <div class="image-comparison">
                    <div class="centered-container">
                        <img src="Images/ScatteringEvent.png" alt="Scattering Event Illustration">
                        <div class="caption">Scattering event occurred.</div>
                    </div>
                    <div class="centered-container">
                        <img src="Images/NoScatteringEvent.png" alt="No Scattering Event Illustration">
                        <div class="caption">No scattering event occurred, sampled distance exceeded volume's boundary.</div>
                    </div>
                </div>

                <p>
                    If the event is absorption, the ray is simply terminated. If it's a scattering event, a new direction has to be sampled based on the medium's phase function.
                </p>
            </section>

            <section id="phase-functions">
                <h2>Phase Functions</h2>
                <p>
                    The phase function describes the angular distribution of scattered light. It defines how likely light is to scatter in a particular direction after an interaction. There are several phase functions commonly used in volumetric rendering, each with its own characteristics and use cases. The most commonly used one is Henyey-Greenstein phase function, which is defined as:
                </p>

                <div class="equation">
                    $$
                    p(\cos \theta) = \frac{1}{4\pi} \frac{1 - g^2}{(1 + g^2 - 2g\cos \theta)^{3/2}}
                    $$
                </div>

                <p>
                    $\theta$ is the angle between the incident direction $\hat v$ and outgoing direction $\omega$, so the function defines the probability of light scattering in a direction $\omega$, where the angle between $\hat v$ and $\omega$ is $\theta$. $g$ is the asymmetry parameter that controls the anisotropy of the scattering. When $g = 0$, the scattering is isotropic (equal in all directions). When $g > 0$, the scattering is forward peaked, meaning light is more likely to scatter forward. When $g < 0$, the scattering is backward peaked, meaning light is more likely to scatter backward.
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/IsotropicDistribution.png" alt="Isotropic Phase Function" width="30%">
                        <div class="caption">Isotropic Phase Function ($g=0$)</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/AnisotropicDistribution.png" alt="Forward Peaked Phase Function" width="80%">
                        <div class="caption">Forward Peaked Phase Function ($g > 0$)</div>
                    </div>
                </div>

                <p>
                    Henyey-Greenstein phase function is widely used due to its simplicity and ability to model a wide range of scattering behaviors with just a single parameter $g$. However, it doesn't accurately represent Mie scattering, which is the scattering of light by particles that are comparable in size to the wavelength of light (like water droplets in clouds). Mie scattering has a more complex angular distribution with both forward and backward scattering components. But it is very expensive to compute.
                </p>

                <p>
                    There are some approximations of it, like <a href="https://research.nvidia.com/labs/rtr/approximate-mie/">An Approximate Mie Scattering Function for Fog and Cloud Rendering</a>. It combines Henyey-Greenstein with Draine phase function to approximate MIE scattering over the range of water droplet sizes from 5 to 50 micro meters. But because it has a weird parameter range based on droplet size, it can be hard to work with and since the difference is very subtle, I went with Henyey-Greenstein for simplicity.
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/HG.png" alt="Henyey-Greenstein Phase Function" width="100%">
                        <div class="caption">Henyey-Greenstein</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/HG_PLUS_DRAINE.png" alt="Henyey-Greenstein Plus Draine Phase Function" width="100%">
                        <div class="caption">Approximated MIE</div>
                    </div>
                </div>

                <p>
                    To sample a new direction based on the Henyey-Greenstein phase function, a random angle between the incident direction $\hat v$ and the outgoing direction $\omega$ is needed. Since we have the probability distribution, just like before, the inverse transform sampling can be used. After doing that with the Henyey-Greenstein phase function, we get the following formula for the cosine of the scattering angle $\theta$:
                </p>

                <div class="equation">
                    $$
                    \cos \theta =
                    \begin{cases}
                    \frac{1}{2g} \left(1 + g^2 - \left(\frac{1 - g^2}{1 - g + 2g\xi}\right)^2\right) & If \; g \neq 0\\
                    2\xi - 1 & If \; g = 0
                    \end{cases}
                    $$
                </div>

                <p>
                    Where $\xi$ is a uniformly distributed random number in the range [0, 1]. Since this is only for the polar angle $\theta$, the azimuthal angle $\phi$ also has to be sampled, though this time it can just be sampled uniformly in the range [0, 2$\pi$] since the phase function doesn't affect it in any way:
                </p>

                <div class="equation">
                    $$
                    \phi = 2\pi \xi'
                    $$
                </div>

                <p>
                    Where $\xi'$ is another uniformly distributed random number in the range [0, 1]. Finally, the spherical coordinates $(\theta, \phi)$ can be converted to Cartesian coordinates to get the new world direction vector $\omega$. This can be done using orthonormal basis constructed from the incident direction $\hat v$:
                </p>

                <div class="equation">
                    $$
                    \begin{aligned}
                    &t = \frac{u \times \hat v}{||u \times \hat v||} \\
                    &b = \hat v \times t \\
                    &\omega = \sin \theta \cos \phi \cdot t + \sin \theta \sin \phi \cdot b + \cos \theta \cdot \hat v
                    \end{aligned}
                    $$
                </div>

                <p>
                    Where $u$ is any vector that is not parallel to $\hat v$. This gives the new direction $\omega$ after the scattering event.
                </p>

                <div class="centered-container column">
                    <img src="Images/PhaseCone.png" alt="Scattered Ray Illustration">
                    <div class="caption">Sampling $\;\omega\;$ from $\;\hat v\;$</div>
                </div>

                <p>
                    And that's pretty much it for the basic tracking algorithm. Now you go to step 1 and sample the distance along the new ray with direction $\omega$. You just keep repeating this process until the ray exits the medium or gets absorbed. Each time a scattering event occurs, you sample a new direction and continue tracking from that point. Over multiple samples, this will give you a good approximation of how light interacts with the participating media.
                </p>

                <div class="centered-container column">
                    <img src="Images/SuzanneNEEImportance25K.png" alt="Homogeneous Media" width="100%">
                    <div class="caption">Room filled with homogeneous volume. Rendered with Next Event Estimation (25k samples per pixel)</div>
                </div>

                <p>
                    The issue is that a lot of samples are needed to get a noise free result, especially in media with high scattering coefficients. To help with that, next event estimation can be used to directly sample light sources during each scattering event, which greatly reduces variance and speeds up convergence. Details about NEE won't be covered here, since it's a separate topic on its own.
                </p>

                <p>
                    Another thing that uniform volumes can be used for is subsurface scattering. By making the surface transparent and filling the mesh with a volume with high scattering and low absorption coefficients, the way light penetrates the surface, scatters internally, and exits at different points can be simulated, creating a soft, translucent appearance. This is particularly useful for rendering materials like skin or wax. The only thing that has to be changed in the tracking algorithm is the boundary, instead of being defined by an AABB, it has to be defined by the mesh. It's easy to implement since all that is needed is distance to the next intersection with the mesh along the ray.
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/DiffuseDragonHead.png" alt="Diffuse Dragon Head" width="100%">
                        <div class="caption">Diffuse</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/DragonHead.png" alt="Subsurface Scattering Dragon Head" width="100%">
                        <div class="caption">Subsurface scattering</div>
                    </div>
                </div>

            </section>

            <section id="heterogeneous-volumes">
                <h2>Heterogeneous Volumes</h2>

                <p>
                    Heterogeneous volumes are more complex than homogeneous ones, as they have varying density across the volume (they are non uniform). So the same equations for free path length sampling and transmittance calculation cannot be used. Instead, the varying density needs to be accounted for.
                </p>

                <p>
                    There are a couple approaches here, each with its own trade-offs:
                </p>

                <p>
                    1. <strong>Regular Tracking</strong>: The idea is to split the heterogeneous volume into smaller homogeneous regions (like a 3D grid) and perform regular tracking within each region. When the ray crosses into a new region, medium properties are updated. This method is straightforward but not feasible for highly detailed volumes as it can lead to a very large number of regions.
                </p>

                <p>
                    2. <strong>Ray Marching</strong>: Instead of sampling the free path length directly, ray marching can be used to step through the volume in small fixed increments. At each step, the medium properties are evaluated to determine whether the scattering/absorption event occured. But the amount of steps required to get a good result will pretty much vary based on the density of the medium, so it's hard to find a good step size that not only performs well but also looks good.
                </p>

                <p>
                    3. <strong>Delta Tracking</strong>: This is a more advanced technique that allows sampling free path lengths in heterogeneous media without needing to subdivide the volume. The idea is to use a majorant extinction coefficient $\sigma_{t}^{max}$ which is the maximum extinction coefficient in the volume. Free path lengths are sampled using this majorant coefficient, when an event occurs, an actual density at that point is evaluated, and based on that the decision is made whether the collision actually happened or if it's a <strong>null collision</strong>. If it's a null collision, sampling continues until an interaction is accepted or the ray exits the volume. This method is more efficient than regular tracking and ray marching for highly detailed volumes, but it can still be computationally expensive for volumes with a lot of empty space.
                </p>

                <p>
                    I went with delta tracking since it seemed like the most promising approach for rendering clouds. Regular Tracking seemed too complicated to implement and manage the data structure for (and it would most likely be a lot slower than delta tracking), and ray marching seemed too inaccurate and required a lot of per volume tweaking to get somewhat good results.
                </p>

                <h3>OpenVDB</h3>

                <p>
                    So, first the density data itself has to be stored somehow. Volumes are usually stored inside a VDB format, which stores sparse volumetric data. Just like with 3D models a lot of these can be found online for free. They store a 3D voxel grid where each voxel contains a density value representing the medium's density at that point in space.
                </p>

                <p>
                    The problem was that OpenVDB (C++ library for working with VDB files) is not compatible with GPU usage, the grid cannot be accessed from the GPU. So at first I decided to convert the VDB into a 3D texture that can be sampled inside the shader. This works fine for small to medium sized volumes, but for really large volumes this can become a problem due to really high memory usage. A 469MB VDB file ended up being 3140MB when converted to a 3D texture, with 12GB of VRAM in my GPU this means it's manageable but I'd be limited to 3-4 volumes of that size at once.
                </p>

                <p>
                    That was less than ideal, so later on I switched to <strong>NanoVDB</strong> which is a GPU implementation of sparse voxel grid. It's a little bit slower (20-30%) since it can't be sampled as fast as a 3D texture, but it uses way less memory, the same 469MB VDB file ended up being only 563MB instead of 3140MB when converted to NanoVDB format, so the trade-off is worth it. The most annoying thing about NanoVDB is it's absolute lack of any documentation, so figuring out how to use it took a lot of trial and error, and I'm still not sure if I'm doing everything correctly.
                </p>

                <h3>Delta Tracking</h3>

                <p>
                    Now onto the actual delta tracking implementation. The idea is to fill the volume with fictional null particles so that the medium can be treated as if it's homogeneous with extinction coefficient $\sigma_{t}^{max}$. Free path lengths are then sampled using this majorant coefficient, and when an event occurs, the actual density at that point is evaluated to decide whether the collision is real or not.
                </p>

                <p>
                    Finding the majorant extinction coefficient is pretty straightforward, just iterate through all the voxels in the volume and find the maximum density value. From that you can compute the maximum extinction coefficient $\sigma_{t}^{max}$ using the medium's scattering and absorption coefficients.
                </p>

                <p>
                    Free path lengths are sampled using the same formula as before, but with the majorant extinction coefficient:
                </p>

                <div class="equation">
                    $$
                    d = -\frac{\ln(\xi)}{\sigma_{t}^{max}}
                    $$
                </div>

                <p>
                    When an event occurs at distance $d$, the actual density $\rho(d)$ at that point in the volume is evaluated. From that the actual extinction coefficient $\sigma_{t}(d)$ can be computed using the medium's scattering and absorption coefficients. The probability of accepting the collision is then given by:
                </p>

                <div class="equation">
                    $$
                    p_{accept} = \frac{\sigma_{t}(d)}{\sigma_{t}^{max}}
                    $$
                </div>

                <p>
                    Another random number $\xi$ uniformly distributed in [0, 1] is generated. If $\xi < p_{accept}$, the collision is accepted as a real interaction (scattering or absorption), otherwise, it's a null collision and sampling continues for the next free path length from that point. This process is repeated until the ray exits the volume.
                </p>

                <p>
                    Another thing is transmittance calculation. In delta tracking, transmittance $T(d)$ over a distance $d$ can't be computed analytically like in homogeneous volumes. Instead, it has to be integrated numerically by simulating a path. So starting at the ray origin, free path lengths are sampled the same way as before using the majorant extinction coefficient. For each sampled distance, the actual density at that point is evaluated and the actual extinction coefficient is computed. If the collision is accepted, the path is terminated and the transmittance is returned as zero (since light is either absorbed or scattered). If it's a null collision, sampling continues until the ray leaves the volume. This gives a binary result of 0 or 1, ray either gets completely absorbed/scattered or exits the volume without interaction. Which is not ideal, but this will be addressed later.
                </p>

                <p>
                    And that's pretty much it for delta tracking in heterogeneous volumes. It's a powerful and unbiased technique that allows you to accurately simulate light interactions in complex media without needing to subdivide the volume into smaller homogeneous regions. However, it can still be computationally expensive, especially for volumes with a lot of empty space, since many null collisions may be sampled before a real interaction occurs. And unfortunately this is visible as soon as you try to render something with it, the performance is just not great.
                </p>

            </section>

            <section id="performance-and-optimizations">
                <h2>Performance And Optimizations</h2>

                <p>
                    Let's load a <a href="https://samk9632.gumroad.com/l/Freebie-Cloud">large cloud VDB file</a> It takes 3817MB of VRAM and is 4161x1454x1915 voxels in size, so it's pretty big. Let's also set absorption coefficient to 0 since clouds have almost no absorption, and anisotropy to 0.9 for strong forward scattering. Now let's try rendering it with delta tracking.
                </p>

                <div class="centered-container column">
                    <img src="Images/Raw_10spp_248s.png" alt="Cloud Rendered with Delta Tracking" width="100%">
                    <div class="caption">Cloud rendered with delta tracking and Next Event Estimation (10 samples per pixel, 248s)</div>
                </div>

                <p>
                    Image above took 248s to compute, and that's for only 10 samples per pixel! The noise is really bad too. And it's only a single cloud, imagine trying to render a whole scene with multiple clouds and other geometry, it would take forever. So clearly some optimizations are needed here.
                </p>

                <h3>Ratio Tracking</h3>
                <p>
                    First, <b>Ratio Tracking</b>. The idea is to attenuate the contribution of each sample based on the ratio of absorption coefficient to extinction coefficient, instead of terminating the path on absorption events. This way, the binary nature of delta tracking can be avoided, that will reduce the variance and with that the noise. So now, instead of terminating the path when an absorption event occurs, contribution of the sample is multiplied by the inverted ratio of absorption coefficient to the extinction coefficient at that point. This way, even if some of the light gets absorbed, it still contributes to the final image, just with reduced weight. This helps to reduce noise and improve convergence. Of course it doesn't help with this specific cloud example, since the absorption coefficient is 0 there is no absorption, but in general it can be very useful.
                </p>

                <div class="equation">
                    $$
                    W = W \cdot (1 - \frac{\sigma_a(d)}{\sigma_t(d)})
                    $$
                </div>

                <p>
                    Also, since only the ratio of absorption to scattering coefficients matters, instead of declaring them separately, they can be merged into a single extinction coefficient (density) and an albedo value that defines the color. Instead of having $\sigma_a$, $\sigma_s$, and color, there's just $\sigma_t$ (density) and albedo $a$ (color). So now the equivalent of $\sigma_a = 0.5$, $\sigma_s = 0.5$, albedo = (1, 1, 1) would be $\sigma_t = 1.0$ and albedo = (0.5, 0.5, 0.5). This makes it easier to define the medium's properties since only two parameters need to be considered instead of three. So $W$ is calculated as:
                </p>

                <div class="equation">
                    $$
                    W = W \cdot a
                    $$
                </div>

                <p>
                    Ratio tracking applies to homogeneous volumes just as well by the way. On the image below a variance reduction is clearly visible.
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/CubeDeltaTracking.png" alt="Cube Rendered with Delta Tracking" width="100%">
                    </div>
                    <div class="centered-container column">
                        <img src="Images/CubeRatioTracking.png" alt="Cube Rendered with Ratio Tracking" width="100%">
                    </div>
                </div>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/CubeDeltaTrackingZoomed.png" alt="Cube Rendered with Delta Tracking" width="100%">
                        <div class="caption">Delta Tracking (25 samples per pixel)</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/CubeRatioTrackingZoomed.png" alt="Cube Rendered with Ratio Tracking" width="100%">
                        <div class="caption">Ratio Tracking (25 samples per pixel)</div>
                    </div>
                </div>

                <p>
                    Ratio tracking can also be used for transmittance calculation in heterogeneous volumes. Instead of returning a binary result of 0 or 1, the transmittance can be accumulated along the path by multiplying it by the inverted ratio of actual extinction coefficient to majorant extinction coefficient at each collision.
                </p>

                <div class="equation">
                    $$
                    T(d) = T(d) \cdot \left(1 - \frac{\sigma_t(d)}{\sigma_{t}^{max}}\right)
                    $$
                </div>

                <p>
                    Where $T(d)$ is initialized to 1 at the start of the transmittance calculation. Each time a collision event occurs, the transmittance is updated by multiplying it with the inverted ratio.
                </p>

                <p>
                    But just adding ratio tracking alone is not enough to make delta tracking fast. The performance is even worse. That's because now the path is not terminated when an absorption event occurs, so the number of scattering events per path increases significantly, leading to more computations and slower rendering times. To combat this Russian Roulette can be used to probabilistically terminate paths that contribute very little to the final image.
                </p>

                <h3>Russian Roulette</h3>
                <p>
                    Russian Roulette is a technique used to probabilistically terminate paths that contribute very little to the final image. The idea is to randomly decide whether to continue or terminate a path based on its contribution weight. If the weight is below a certain threshold, the path can be terminated, and if the decision is to continue, the weight of the path is scaled up to account for the probability of termination. This helps to reduce the number of samples needed to achieve a certain level of convergence, especially in scenes with high variance.
                </p>

                <p>
                    After every scattering event, the contribution weight $W$ of the path is evaluated. A random number $\xi$ uniformly distributed in [0, 1] is generated. If $\xi < p_{rr}$, where $p_{rr}$ is the probability of termination, the path is terminated. Otherwise, the weight is scaled up by dividing it by $p_{rr}$ to account for the probability of termination.
                </p>

                <p>
                    so if $W$ is the contribution weight after a scattering event, the Russian Roulette step can be defined as:
                </p>

                <div class="equation">
                    $$
                    W^{\prime} = 
                    \begin{cases}
                    0 & \xi \geq p_{rr} \\
                    \frac{W}{p_{rr}} & Otherwise
                    \end{cases}
                    $$
                </div>

                <p>
                    The expected value remains the same, so the image will converge to the same result eventually.
                </p>

                <div class="equation">
                    $$
                    E[W^{\prime}] = (1 - p_{rr}) \cdot 0 + p_{rr} \cdot \frac{E[W]}{p_{rr}}= E[W]
                    $$
                </div>

                <p>
                    So as long as the probability of termination is chosen wisely, Russian Roulette can significantly speed up rendering times without introducing bias. Setting $p_{rr}$ to the highest value of one of the color channels of the ray seems to work well. The same can be applied to transmittance calculation. But in that case the probability of termination can be set to the transmittance value itself since there are no color channels. As mentioned before, it won't do much in this specific cloud example since the absorption coefficient is 0, but in mediums with non-zero absorption it can greatly improve performance.
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/2556s200spp.png" alt="" width="100%">
                        <div class="caption">2556s without Russian Roulette, max depth 200, biased</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/161s200spp.png" alt="Cube Rendered with Ratio Tracking" width="100%">
                        <div class="caption">161s with Russian Roulette, unbiased</div>
                    </div>
                </div>

                <h3>Region Subdivision</h3>
                <p>
                    The biggest issue with delta tracking is that in volumes with a lot of empty space, many null collisions will be sampled before a real interaction occurs, and that means a lot of wasted time. To mitigate this, the volume can be subdivided into smaller regions, each with its own majorant extinction coefficient. This way, when the ray enters a new region, the majorant extinction coefficient can be updated to better match the local density of the medium, reducing the number of null collisions in empty regions.
                </p>

                <p>
                    I subdivided the volumes into a 32x32x32 grid of regions, too many subdivisions would slow down less dense volumes, and too few would result in way too many null collisions, so after some testing 32 seemed to be a good compromise. For each region, the maximum density value is computed and used to calculate the majorant extinction coefficient for that region. During tracking, when the ray crosses into a new region, the majorant extinction coefficient is updated accordingly. This significantly reduces the number of null collisions since the empty regions are skipped almost immediately instead of sampling null collisions. Here's a comparison:
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/NullCollisionOptOff.png" alt="NullCollisionOptOff" width="100%">
                        <div class="caption">No subdivision</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/NullCollisionOptOn.png" alt="NullCollisionOptOn" width="100%">
                        <div class="caption">With subdivision</div>
                    </div>
                </div>

                <p>
                    On the images above, every time a null collision is sampled, the brightness of that pixel is incremented by a small amount, so the darker the image the better. As you can see, with region subdivision the number of null collisions is massively reduced.
                </p>

                <div class="image-comparison">
                    <div class="centered-container column">
                        <img src="Images/NullCollisionOptOff216s.png" alt="NullCollisionOptOff216s" width="100%">
                        <div class="caption">No subdivision 216s</div>
                    </div>
                    <div class="centered-container column">
                        <img src="Images/NullCollisionOptOn33s.png" alt="NullCollisionOptOn33s" width="100%">
                        <div class="caption">With subdivision 33s</div>
                    </div>
                </div>

                <p>
                    With subdivision the render time is reduced from 216s to 33s, which is a huge improvement considering it stays completely unbiased and is pretty much free.
                </p>

                <p>
                    Since most of the volume in the cloud example is empty, it benefits greatly from the subdivision. It now takes only 14s to render at 10 samples per pixel, which is a massive improvement from the 248s.
                </p>

                <div class="centered-container column">
                    <img src="Images/RegionOpt_10spp_14s.png" alt="Final Cloud Rendered with Region Optimization" width="100%">
                    <div class="caption">Rendered with Region Optimization and Next Event Estimation (10 samples per pixel 14s)</div>
                </div>

                <h3>Biasing the sampling</h3>

                <p>
                    Since clouds are really dense, really big, and highly anisotropic, they produce a lot of scattering events over really short distances in a similiar direction. This means that most of the time the amount of rays that have to be traced per path is huge, which increases variance and render times. <a href="https://media.disneyanimation.com/uploads/production/publication_asset/177/asset/a.pdf">The Design and Evolution of Disney’s Hyperion Renderer</a> proposes a solution to this problem, as the ray progresses through the medium, the density of said medium is lowered alongside the anisotropy. This way, the sampled distance become a lot larger and the amount of rays per path is reduced, which reduces variance and speeds up convergence. And since the anisotropy is also reduced, the final image still looks somewhat correct. This does introduce some bias, but in practice the visual difference is minimal, and the performance gain is definitely worth it.
                </p>

                <p>
                    In the paper they reduce the density and anisotropy linearly between 5th and 20th bounce, but honestly, I didn't notice much difference between that and just reducing them both throughout the whole path. So I just did that since it's faster, less events will be sampled.
                </p>

                <p>
                    Anisotropy is reduced like this:
                </p>

                <div class="equation">
                    $$
                    g^\prime = |g|^{1 + d} \cdot \text{sign}(g)
                    $$
                </div>

                <p>
                    with $d$ being the depth. And density is reduced like this:
                </p>

                <div class="equation">
                    $$
                    \sigma_{t}^{\prime} = \sigma_{t} \cdot b^{d}
                    $$
                </div>

                <p>
                    with $b$ being the bias factor (between 0 and 1). After implementing that, the bias factor was set to 0.8, which seems to work well for clouds. With that the render time is down to 1.1s for 10 samples per pixel! So again, a huge improvement over the initial 248s. The image is also a lot less noisy since now the paths are shorter which means there's less variance.
                </p>

                <div class="centered-container column">
                    <img src="Images/BiasOpt_10spp_1s.png" alt="Cloud Rendered with Biased Sampling" width="100%">
                    <div class="caption">Rendered with biased sampling and Next Event Estimation (10 samples per pixel 1s)</div>
                </div>

                <p>
                    I didn't experiment with different ways of reducing density and anisotropy, but it's definitely worth exploring further. Another possible optimization is to calculate direct lighting only at the first and last scattering events. This way, the number of light samples per path is reduced significantly, which speeds up rendering times. The visual difference is minimal since most of the direct lighting contribution comes from the first and last scattering events anyway. I haven't implemented it yet, but it's definitely worth exploring in the future.
                </p>

            </section>

            <section id="results-and-comparison">
                <h2>Results and Comparison</h2>
                
                <h3>Performance Summary</h3>
                <p>
                    Here's a comprehensive breakdown of the performance improvements achieved through various optimizations:
                </p>
                
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid #ddd; padding: 8px;">Technique</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Render Time (10 spp)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Speedup</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Quality Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">Basic Delta Tracking</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">~248s</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">1.0x</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Unbiased</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">+ Ratio Tracking and Russian Roulette</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">~255s</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">0.97x</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Lower noise</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">+ Region Subdivision</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">~14s</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">17.7x</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Unchanged</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">+ Biased Sampling</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">~1s</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">225x</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Slightly biased</td>
                        </tr>
                    </tbody>
                </table>

                <div class="centered-container column">
                    <img src="Images/Final_1000spp_123s.png" alt="Final Cloud Rendered" width="100%">
                    <div class="caption">Final Cloud (1000 samples per pixel 123s)</div>
                </div>

                <p>
                    Though even with the 225x speedup from biased sampling, the render time for a clean image at 1000 samples per pixel is still around 123s. So high scattering media like clouds still remain pretty computationally expensive.
                </p>

                <p>
                    Image below showcases 3 really high density clouds rendered together. The render time for this at 5000 samples per pixel is 996s, which is quite long, but still manageable for offline rendering.
                </p>

                <div class="centered-container column">
                    <img src="Images/Cloud1.png" alt="Final Cloud Rendered" width="100%">
                    <div class="caption">5000 samples per pixel, 996s</div>
                </div>

                <p>
                    A lot of the cost can be cut using a denoiser, which I'm not doing here. All of the images here were not denoised in any way. Which means that realistically with a good denoiser and some adaptive sampling a lot less samples would be needed for a good looking image.
                </p>

            </section>
        </div>
    </div>
</body>
</html>